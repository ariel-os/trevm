# trevm
Tiny Rust embedded virtual machines bolted on Ariel OS. To learn more about Ariel OS check out the [repo](https://github.com/ariel-os/ariel-os) and follow the [getting started](https://ariel-os.github.io/ariel-os/dev/docs/book/getting-started.html) guide.

## WebAssembly

Currently, the only VM Provider that has been tested with Ariel OS is WebAssembly. Currently, [Wasmtime](https://github.com/bytecodealliance/wasmtime) is the only WebAssembly that is supported. Support for this is experimental and the implementation is subject to change.

### Requirements

On top of the requirements for basic Ariel OS usage, to turn rust code into components the `wasm32v1-none` target should be installed for your toolchain using `rustup target add wawm32v1-none` and so should the [`wasm-tools`](https://github.com/bytecodealliance/wasm-tools) CLI utility. Ariel OS works on stable and so does the rust to wasm compilation workflow but we advocate the use of a (recent) nightly compiler for two reasons:
- Compiling the wasm payloads is a three step process. We provide a rust script that does those steps in sequence and running scripts requires nightly.
- Wasm binaries have by default a memory page size of 65536 bytes. It is possible to go below but support for this was only added in LLVM 21 which is only used by fairly recent nightly `rustc`. `nightly-09-01` is known to work and is the nightly version that was used when developing this.

### Structure of the WebAssembly support

The bindings can be found in [`src/ariel-os-bindings/src/wasm`](./src/ariel-os-bindings/src/wasm/). They are taylored for Wasmtime and will not work with another runtime. The bindings are partially auto-generated by the use of the [WebAssembly component model](FIXMELink). The WIT interfaces that are made available to wams components are defined in [`wit/deps/ariel`](./wit/deps/ariel/).

### Examples

Examples are in the `examples/` directory. They can be run using the [`laze`](https://github.com/kaspar030/laze) build system. Examples work by embarkin their payload at compile time. Changing the payload requires to go through the following steps:
- Compiling some code to a wasm module
- Turning the wasm module into a wasm component
- Precompiling this component to make it usable by wasmtime in `no_std` contexts.
The `precompile_wasm.rs` script takes in a path to rust manifest (`Cargo.toml`) and outputs a precompiled component to make this process less time consuming.
The source code for the payload used in the examples in the [`payloads`](./payloads/) directory. After modifying the code in for example `payloads/async-bindings/src/lib.rs`, the corresponding example's payload can be changed by using the script in the following way
```sh
#  nightly is required to use -Z script
cargo +nightly -Z script precompile_wasm.rs --toolchain "+nightly-2025-09-01" --path payloads/async-bindings/Cargo.toml --config payloads/.cargo/config.toml -o examples/async-bindings/payload.cwasm
```
